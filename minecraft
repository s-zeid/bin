#!/usr/bin/env python

"""Runs Minecraft.

Launchers should be placed in `~/.minecraft/launchers/`, and a `launchers.yml`
file describing each launcher should be placed in the same directory.  These
paths will be created if necessary, with sane defaults (i.e. it will try to
run the stock launcher first, then the new dev launcher, then Magic Launcher
as MagicLauncher.jar).  You will, however, need to manually add the JAR files.

If no launcher is given, then the first launcher in launchers.yml that exists
will be executed.

Optional environment variables:

 - `MC_LAUNCHERS_PATH`:  Overrides the launchers directory
 - `MC_LAUNCHERS_YML`:   Overrides the path to launchers.yml.
    May be either relative to the launchers directory or absolute.

If this script is invoked as `minceraft`, then it may or may not force the
client to flip the E and C in the title screen logo.

Depends on Python 2.7, PyYAML, and python-which:

    fedora$ sudo yum install python-which PyYAML
    ubuntu$ sudo apt-get install python-{yaml,pip} && sudo pip install which

launchers.yml should look like this (as an example):

    launchers:
     dev:
      jar:     MinecraftDev.jar
     stock:
      jar:     Minecraft.jar

The ordering of the launchers is important.  Without arguments, the first
launcher in the list whose JAR file exists will be executed.

`jar` is either the relative (to `~/.minecraft/launchers/`) or absolute path to
the launcher's JAR file.

(optional) `env` is a mapping of environment variables to pass to the launcher.
This can be specified either as part of a launcher or globally.  Environment
variables specified inside a launcher key will take precedence.

"""

import math
import os
import platform
import re
import socket
import subprocess
import sys
import time

try:
 # OrderedDict is included in standard library from Python 2.7
 from collections import OrderedDict
except ImportError:
 # try importing the backport from PyPI
 from ordereddict import OrderedDict

import yaml
import yaml.constructor

# We want the python-which module if it's available, but if it's not, use a
# minimal implementation that runs the system which command.  On Windows,
# an ImportError will be raised if the real which module is unavailable
# because Windows doesn't have a which command.
try:
 import which
except ImportError:
 if platform.system() == "Windows":
  raise ImportError("The which module is required on Windows")
 class which(object):
  class WhichError(Exception): pass
  @classmethod
  def which(cls, what):
   p = subprocess.Popen(["which", what], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
   if p.wait() == 0:
    return p.communicate()[0].rstrip("\r\n\0")
   else:
    raise cls.WhichError("Could not find '%s' on the path." % what)

DEFAULT_LAUNCHERS_PATH = "~/.minecraft/launchers"
DEFAULT_LAUNCHERS_YML  = "launchers.yml"
DEFAULT_YML_CONTENTS = """\
launchers:
 stock:
  jar:     Minecraft.jar
 dev:
  jar:     MinecraftDev.jar
 magic:
  jar:     MagicLauncher.jar
"""

def main(argv):
 if len(argv) > 1 and argv[1] in ("--help", "-h"):
  if len(argv) > 2 and argv[2] == "launchers.yml":
   print "launchers.yml " + __doc__.split("\n\nlaunchers.yml ")[1].rstrip()
  else:
   print "Usage: %s [--<launcher-name> or --help|-h or --] [launcher_args ...]" % argv[0]
   if len(argv) > 2 and argv[2] == "all":
    print __doc__.rstrip()
   else:
    print __doc__.split("\n\nlaunchers.yml ")[0] + "\n"
    print "For information on the format of launchers.yml, run:\n"
    print "    %s %s launchers.yml" % tuple(argv[:2])
  return 0
 
 config = load_config(
  os.environ.get("MC_LAUNCHERS_PATH", None), os.environ.get("MC_LAUNCHERS_YML", None)
 )
 launchers = config["launchers"]
 if len(launchers) == 0:
  print >> sys.stderr, "error: no launchers configured in launchers.yml"
  return 4
 
 # See if a launcher is requested in argv[1] (must be a key in launchers.yml::launchers).
 # Our launchers dict will be len(1) and want will not be None if a launcher is given.
 # Invalid launchers will result in a warning because they may be a valid argument to
 # the default launcher.
 if len(argv) > 1 and argv[1] == "--":
  want = None
  args = argv[2:]
 elif len(argv) > 1 and argv[1].startswith("--"):
  want = argv[1][2:]
  if want in launchers:
   launchers = {want: launchers[want]}
   args = argv[2:]
  else:
   print >> sys.stderr, "warning: invalid launcher '%s'" % want
   return 2
 else:
  want = None
  args = argv[1:]
 
 # Find which launcher to use.  If want == None (i.e. no launcher was requested
 # as argv[1]), then we will use the first launcher whose .jar file exists and
 # is a regular file (or a symlink to one).
 launcher = None
 for name in launchers:
  l = launchers[name]
  if os.path.isfile(os.path.realpath(l["jar"])):
   launcher = l
   break
  elif want:
   print >> sys.stderr, ("error: the jar file '%s' does not exist or is not a regular file"
                         % l["jar"])
   return 1
 if launcher == None:
  print >> sys.stderr, "error: no launcher JAR could be found"
  return 5
 
 # On Linux, it is at least sometimes necessary to explicitly add the JRE
 # native library path to LD_LIBRARY_PATH, so we do that, as well as check
 # to see if Java is on the user's PATH (which is necessary on all platforms).
 try:
  java = which.which("java")
 except which.WhichError:
  print >> sys.stderr, "error: java is not in your PATH"
  return 3
 java_home = re.sub(r"[\\/]bin[\\/]java$", "", os.path.realpath(java))
 ld_library_path = None
 if platform.system() == "Linux":
  if platform.architecture()[0] == "64bit":
   ld_library_path = os.path.join(java_home, "lib/amd64")
  elif platform.architecture()[0] == "32bit":
   ld_library_path = os.path.join(java_home, "lib/i386")
 
 # Populate the environment
 environ = os.environ.copy()
 if ld_library_path:
  if "LD_LIBRARY_PATH" in environ:
   environ["LD_LIBRARY_PATH"] = ld_library_path + ":" + environ["LD_LIBRARY_PATH"]
  else:
   environ["LD_LIBRARY_PATH"] = ld_library_path
 if config.get("env", None):
  environ.update(OrderedDict([(k, str(config["env"][k])) for k in config["env"]]))
 if launcher.get("env", None):
  environ.update(OrderedDict([(k, str(launcher["env"][k])) for k in launcher["env"]]))

 # Run (https://youtu.be/_PUtC6SC2h8)
 os.execvpe("java", ["java", "-jar", launcher["jar"]] + argv[1:], environ)

def load_config(path=None, yml=None):
 if not path: path = DEFAULT_LAUNCHERS_PATH
 if not yml:  yml  = DEFAULT_LAUNCHERS_YML
 path = os.path.expanduser(path)
 yml  = os.path.expanduser(yml)
 
 if not os.path.isabs(yml): yml = os.path.join(path, yml)
 
 if not os.path.exists(path):
  os.mkdir(path, 0755)
 if not os.path.exists(os.path.realpath(yml)):
  with open(yml, "w") as fo:
   fo.write(DEFAULT_YML_CONTENTS)
 
 with open(yml, "rb") as fo:
  config = yaml.load(fo.read().decode("utf-8"), OrderedDictYAMLSafeLoader)
 
 config["path"] = path
 config["yml"] = yml
 
 # Expand JAR paths and convert string wmclass values to single-element lists
 launchers = config["launchers"]
 for name in launchers:
  l = launchers[name]
  if not os.path.isabs(l["jar"]):
   l["jar"] = os.path.expanduser(os.path.join(path, l["jar"]))
 
 return config

# We need to load YAML mappings as OrderedDicts in order to preserve the ordering
# of launcher entries while keeping the launchers.yml schema clean and easy to
# write by hand.
class OrderedDictYAMLSafeLoader(yaml.SafeLoader):
 """
 A YAML loader that loads mappings into ordered dictionaries.
 By enaeseth:  https://gist.github.com/enaeseth/844388
 """

 def __init__(self, *args, **kwargs):
  yaml.SafeLoader.__init__(self, *args, **kwargs)

  self.add_constructor(u'tag:yaml.org,2002:map', type(self).construct_yaml_map)
  self.add_constructor(u'tag:yaml.org,2002:omap', type(self).construct_yaml_map)

 def construct_yaml_map(self, node):
  data = OrderedDict()
  yield data
  value = self.construct_mapping(node)
  data.update(value)

 def construct_mapping(self, node, deep=False):
  if isinstance(node, yaml.MappingNode):
   self.flatten_mapping(node)
  else:
   raise yaml.constructor.ConstructorError(None, None,
    'expected a mapping node, but found %s' % node.id, node.start_mark)

  mapping = OrderedDict()
  for key_node, value_node in node.value:
   key = self.construct_object(key_node, deep=deep)
   try:
    hash(key)
   except TypeError, exc:
    raise yaml.constructor.ConstructorError('while constructing a mapping',
     node.start_mark, 'found unacceptable key (%s)' % exc, key_node.start_mark)
   value = self.construct_object(value_node, deep=deep)
   mapping[key] = value
  return mapping

def to_unicode(s, encoding="utf8"):
 """Returns a Unicode version of the given object."""
 if isinstance(s, unicode):
  return s
 if isinstance(s, (str, buffer)):
  return unicode(s, encoding)
 return unicode(s)

if __name__ == "__main__":
 sys.exit(main(sys.argv))
