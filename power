#!/usr/bin/env python3

import argparse
import decimal
import os
import socket
import socketserver
import sys

from collections import OrderedDict
from typing import *


POWER_SUPPLY_ROOT = "/sys/class/power_supply"
DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 33579


def main(argv: List[str]) -> int:
 p = argparse.ArgumentParser(description="Display or serve power status.")
 p.add_argument("--daemon", "-d", dest="daemon", action="store_true",
                help="run as a daemon")
 fg = p.add_argument_group("optional field arguments",
                           "If more than one field name is given, each field"
                           " will be printed on a separate line, and each line"
                           " will be prefixed with the name of the field and an"
                           " equals sign.  Fields will be printed in the order"
                           " given.  If no field names are given, then only the"
                           " `human` field will be shown.")
 fields = make_status_dict(help_text=True)
 for k in fields:
  fg.add_argument("--" + k.replace("_", "-"), dest="only_fields", 
                 action="append_const", const=k,
                 help="show " + fields[k])
 fg.add_argument("--all", "-a", dest="all_fields", action="store_true",
                 help="show all fields")
 p.add_argument("--hep", dest="_hep_easter_egg", action="store_true",
                help=argparse.SUPPRESS)
 p.add_argument("hostport", nargs="?", default="",
                help="the host and port number to connect or bind to"
                     " (defaults to %s:%d)" % (DEFAULT_HOST, DEFAULT_PORT))
 
 # Make it say "[host][:port]" for hostport in the help and usage text
 # Trying to do it with metavar causes an AssertionError
 def fixup(s):
  s = s.replace("[hostport]", "hostport")
  s = s.replace("hostport     ", "hostport")
  s = s.replace("hostport", "[host][:port]")
  return s
 __format_help = p.format_help
 p.format_help = lambda: fixup(__format_help())  # type: ignore
 __format_usage = p.format_usage
 p.format_usage = lambda: fixup(__format_usage())  # type: ignore
 
 try:
  args = p.parse_args(argv[1:])
 except SystemExit as exc:
  return exc.code
 
 host = port = root = None
 hostport = args.hostport
 if ":" not in hostport:
  hostport += ":"
 host, port = hostport.split(":")
 
 if args._hep_easter_egg:
  print("Hep!  Hep!  I'm covered in sawlder! ... Eh?  Nobody comes.")
  print("--Red Green, https://www.youtube.com/watch?v=qVeQWtVzkAQ#t=6m27s")
  return 0
 
 elif args.daemon:
  # TODO: background
  daemon(host=host, port=int(port) if port else None)
  return 0
 
 else:
  status = power(root=root, host=host, port=int(port) if port else None)
  if args.all_fields:
   print(format_power(status))
  else:
   only_fields = args.only_fields or ["human"]
   for k in only_fields:
    out = ""
    if len(only_fields) != 1:
     out += k + "="
    out += str(status[k])
    print(out)
  return 0


class PowerHandler(socketserver.BaseRequestHandler):
 def handle(self):
  self.request.send(format_power(power()).encode("utf-8") + b"\n")
  self.request.shutdown(socket.SHUT_RDWR)
  self.request.close()


class PowerServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
 allow_reuse_address = True


def daemon(host: str = None, port: int = None):
 server = PowerServer((host or DEFAULT_HOST, port or DEFAULT_PORT), PowerHandler)
 try:
  server.serve_forever()
 finally:
  server.shutdown()


def format_power(power: dict) -> str:
 return "\n".join(["%s=%s" % (k, power[k]) for k in power])


def power(root: str = None, host: str = None, port: int = None) -> dict:
 if host or port:
  return power_remote(host, port)
 return power_local(root)


def power_remote(host: str = None, port: int = None) -> dict:
 s = ""
 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 try:
  sock.connect((host or DEFAULT_HOST, port or DEFAULT_PORT))
  while True:
   data = sock.recv(1024)
   if not data:
    break
   s += data.decode("utf-8")
 finally:
  sock.close()
 
 r = make_status_dict()
 for line in s.splitlines():
  key, value = line.split("=")
  r[key] = value
 return r


def make_status_dict(help_text: bool = False) -> dict:
 def help(s):
  return s if help_text else None
 
 d: dict = OrderedDict()
 d["human"]         = help("human-readable status")
 d["supply"]        = help("the power supply source")
 d["status"]        = help("the general state of the power supply")
 d["percent"]       = help("the percentage of power available")
 d["remaining"]     = help("how much time is remaining to charge or discharge"
                           " in H:MM:SS format")
 d["hours"]         = help("the hours component of the time remaining")
 d["minutes"]       = help("the minutes component of the time remaining")
 d["seconds"]       = help("the seconds component of the time remaining")
 d["total_seconds"] = help("how much time is remaining in seconds")
 return d


def power_local(root: str = None) -> dict:
 power_supplies = sorted(os.listdir(root or POWER_SUPPLY_ROOT))
 ac = None
 battery = None
 status = make_status_dict()
 for i in power_supplies:
  type_ = read(i, "type").lower()
  if type_ == "mains" and ac is None:
   ac = i
  elif type_ == "battery" and battery is None:
   battery = i
  if ac and battery:
   break
 
 battery_status = ""
 if ac is None and battery is None:
  status["supply"] = status["status"] = "Unknown"
 else:
  current_now = float(read(battery, "current_now") or 0)
  charge_now  = float(read(battery, "charge_now") or 0)
  charge_full = float(read(battery, "charge_full") or 0)
  capacity    = float(read(battery, "capacity") or 0)
  if capacity:
   status["percent"] = round_half_up(capacity)
  elif charge_full > 0:
   status["percent"] = round_half_up(charge_now / charge_full) * 100
  
  battery_status = read(battery, "status").lower()
  if battery_status in ("discharging", "charging"):
   if current_now > 0:
    top = charge_full - charge_now if battery_status == "charging" else charge_now
    status["total_seconds"] = round_half_up(3600 * top / current_now)
    status["hours"]         = round_half_up(status["total_seconds"] / 3600)
    status["minutes"]       = round_half_up(status["total_seconds"] / 60) % 60
    status["seconds"]       = round_half_up(status["total_seconds"] % 60)
    status["remaining"]     = "%02d:%02d" % (status["minutes"], status["seconds"])
    if status["hours"]:
     status["remaining"]    = str(status["hours"]) + ":" + status["remaining"]
  if battery_status == "discharging":
   status["supply"] = "Battery"
   status["status"] = "Discharging"
  elif read(ac, "online") == "1":
   status["supply"] = "AC Adapter"
   if battery_status != "":
    if status["percent"] < 100 or battery_status == "charging":
     status["status"] = "Charging"
    else:
     status["status"] = "Charged"
   else:
    status["status"] = "Plugged in"
 
 if battery_status != "":
  if status["status"].lower() == "charged":
   status["human"] = status["status"]
  elif status["remaining"] is not None:
   time_type = "until charged" if status["status"].lower() == "charging" else "remaining"
   status["human"] = "%s, %s%%, %s %s" % (status["status"], status["percent"],
                                          status["remaining"], time_type)
  else:
   status["human"] = "%s, %s%%" % (status["status"], status["percent"])
 else:
  status["human"] = status["status"]
 
 return status


def read(supply: Optional[str], field: Optional[str], root: str = None) -> str:
 path = os.path.join(root or POWER_SUPPLY_ROOT, supply or "", field or "")
 if os.path.exists(path):
  with open(path, "rb") as f:
   return f.read().decode("utf-8").strip()
 return ""


def round_half_up(n: Union[int, float, decimal.Decimal]) -> int:
 return int(decimal.Decimal(n).quantize(1, rounding=decimal.ROUND_HALF_UP))


if __name__ == "__main__":
 try:
  sys.exit(main(sys.argv))
 except KeyboardInterrupt:
  pass
