#!/usr/bin/env python2

import argparse
import os
import socket
import SocketServer
import sys

from collections import OrderedDict

POWER_SUPPLY_ROOT = "/sys/class/power_supply"
DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 33579

def main(argv):
 p = argparse.ArgumentParser(description="Display or serve power status.")
 p.add_argument("--daemon", "-d", dest="daemon", action="store_true",
                help="run as a daemon")
 fg = p.add_argument_group("optional field arguments",
                           "If more than one field name is given, each field"
                           " will be printed on a separate line, and each line"
                           " will be prefixed with the name of the field and an"
                           " equals sign.  Fields will be printed in the order"
                           " given.  If no field names are given, then only the"
                           " `human` field will be shown.")
 for k in make_status_dict():
  fg.add_argument("--" + k.replace("_", "-"), dest="only_fields", 
                 action="append_const", const=k,
                 help="show the %s field" % k)
 fg.add_argument("--all", "-a", dest="all_fields", action="store_true",
                 help="show all fields")
 p.add_argument("hostport", nargs="?", default="",
                help="the host and port number to connect or bind to"
                     " (defaults to %s:%d)" % (DEFAULT_HOST, DEFAULT_PORT))
 
 # Make it say "[host][:port]" for hostport in the help and usage text
 # Trying to do it with metavar causes an AssertionError
 def fixup(s):
  s = s.replace("[hostport]", "hostport")
  s = s.replace("hostport     ", "hostport")
  s = s.replace("hostport", "[host][:port]")
  return s
 __format_help = p.format_help
 p.format_help = lambda: fixup(__format_help())
 __format_usage = p.format_usage
 p.format_usage = lambda: fixup(__format_usage())
 
 try:
  args = p.parse_args(argv[1:])
 except SystemExit as exc:
  return exc.code
 
 host = port = root = None
 hostport = args.hostport
 if ":" not in hostport:
  hostport += ":"
 host, port = hostport.split(":")
 
 if args.daemon:
  # TODO: background
  daemon(host=host, port=int(port) if port else None)
  return 0
 else:
  status = power(root=root, host=host, port=int(port) if port else None)
  if args.all_fields:
   print format_power(status)
  else:
   only_fields = args.only_fields or ["human"]
   for k in only_fields:
    out = ""
    if len(only_fields) != 1:
     out += k + "="
    out += str(status[k])
    print out

class PowerHandler(SocketServer.BaseRequestHandler):
 def handle(self):
  self.request.send(format_power(power()) + "\n")
  self.request.shutdown(socket.SHUT_RDWR)
  self.request.close()

class PowerServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
 allow_reuse_address = True

def daemon(host=None, port=None):
 server = PowerServer((host or DEFAULT_HOST, port or DEFAULT_PORT), PowerHandler)
 try:
  server.serve_forever()
 finally:
  server.shutdown()

def format_power(power):
 return "\n".join(["%s=%s" % (k, power[k]) for k in power])

def power(root=None, host=None, port=None):
 if host or port:
  return power_remote(host, port)
 return power_local(root)

def power_remote(host=None, port=None):
 s = ""
 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 try:
  sock.connect((host or DEFAULT_HOST, port or DEFAULT_PORT))
  while True:
   data = sock.recv(1024)
   if not data:
    break
   s += data
 finally:
  sock.close()
 
 r = make_status_dict()
 for line in s.splitlines():
  key, value = line.split("=")
  r[key] = value
 return r

def make_status_dict():
 d = OrderedDict()
 d["human"]         = None
 d["supply"]        = None
 d["status"]        = None
 d["percent"]       = None
 d["remaining"]     = None
 d["hours"]         = None
 d["minutes"]       = None
 d["seconds"]       = None
 d["total_seconds"] = None
 return d

def power_local(root=None):
 power_supplies = sorted(os.listdir(root or POWER_SUPPLY_ROOT))
 ac = None
 battery = None
 status = make_status_dict()
 for i in power_supplies:
  type_ = read(i, "type").lower()
  if type_ == "mains" and ac == None:
   ac = i
  elif type_ == "battery" and battery == None:
   battery = i
  if ac and battery:
   break
 
 battery_status = ""
 if ac == None and battery == None:
  status["supply"] = status["status"] = "Unknown"
 else:
  current_now = float(read(battery, "current_now") or 0)
  charge_now  = float(read(battery, "charge_now") or 0)
  charge_full = float(read(battery, "charge_full") or 0)
  capacity    = float(read(battery, "capacity") or 0)
  if capacity:
   status["percent"] = int(round(capacity))
  elif charge_full > 0:
   status["percent"] = int(round(charge_now / charge_full) * 100)
  
  battery_status = read(battery, "status").lower()
  if battery_status in ("discharging", "charging"):
   if current_now > 0:
    top = charge_full - charge_now if battery_status == "charging" else charge_now
    status["total_seconds"] = int(round(3600 * top / current_now))
    status["hours"]         = int(round(status["total_seconds"] / 3600))
    status["minutes"]       = int(round(status["total_seconds"] / 60)) % 60
    status["seconds"]       = int(round(status["total_seconds"] % 60))
    status["remaining"]     = "%02d:%02d" % (status["minutes"], status["seconds"])
    if status["hours"]:
     status["remaining"]    = str(status["hours"]) + ":" + status["remaining"]
  if battery_status == "discharging":
   status["supply"] = "Battery"
   status["status"] = "Discharging"
  elif read(ac, "online") == "1":
   status["supply"] = "AC Adapter"
   if battery_status != "":
    if status["percent"] < 100 or battery_status == "charging":
     status["status"] = "Charging"
    else:
     status["status"] = "Charged"
   else:
    status["status"] = "Plugged in"
 
 if battery_status != "":
  if status["status"].lower() == "charged":
   status["human"] = status["status"]
  elif status["remaining"] is not None:
   time_type = "until charged" if status["status"].lower() == "charging" else "remaining"
   status["human"] = "%s, %s%%, %s %s" % (status["status"], status["percent"],
                                          status["remaining"], time_type)
  else:
   status["human"] = "%s, %s%%" % (status["status"], status["percent"])
 else:
  status["human"] = status["status"]
 
 return status

def read(supply, field, root=None):
 path = os.path.join(root or POWER_SUPPLY_ROOT, supply or "", field or "")
 if os.path.exists(path):
  with open(path, "rb") as f:
   return f.read().strip()
 return ""

if __name__ == "__main__":
 try:
  sys.exit(main(sys.argv))
 except KeyboardInterrupt:
  pass
