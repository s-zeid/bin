#!/bin/sh

MAGIC=362bfa2a-044b-11e7-830c-aa000047a7d4
NAME=lowstream

HOST=0.0.0.0
PORT=2629
AB=16
AR=16000


usage() {
 local SIZE_EST_HOURS=2
 local SIZE_EST_SEC="3600*$SIZE_EST_HOURS"
 local SIZE_EST_MUXER_OVERHEAD='1.0387'
 local SIZE_EST_MB_EXPR="$AB*$SIZE_EST_SEC*$SIZE_EST_MUXER_OVERHEAD/8/1024"
 local SIZE_EST_MB="$(bc_round "$SIZE_EST_MB_EXPR")"
 
 cat <<USAGE
Usage: $0 <url> [<port (default: $PORT)>]

This streams audio/video content at the given URL as audio only at low quality
settings.  This is intended for use in client environments where the network is
either too slow or too metered for higher quality streams.  The audio is encoded
as Opus at $AB kbps and $AR Hz with one channel, and the stream is served over
plain HTTP, on port $PORT by default, inside an Ogg container.  The resulting
file size for a $SIZE_EST_HOURS-hour-long input should be approximately $SIZE_EST_MB MB.

This script may be used in conjunction with youtube-dl by giving a URL in the
following format:

    ytdl:[<format>/]<url>

To specify an order of preference for the format, use semicolons instead of
slashes; e.g. \`bestaudio;best\` instead of \`bestaudio/best\`.

If the format is omitted, it will default to \`worstaudio;worst\`.

If the client's request URL ends with \`?dl\`, \`/dl\`, \`?download\`, or
\`/download\`, then the client will be asked to save the audio to a file as
opposed to streaming it. In download mode, static files will be read as fast
as possible instead of sending the output in realtime.

The request URL, minus any query string, will be used as the filename and (minus
any extension) as the metadata title.  The defaults are \`$NAME.ogg\` and
\`$NAME\`, respectively.
USAGE
}


bc_round() {  # non-negative inputs only
 for i; do
  printf 'scale=1\ni=%s\no=i*10/10\nif (i*100%%100 < 5) o else o+.1\n' "$i" | bc
 done
}


main() {
 if [ $# -lt 1 ]; then
  usage >&2
  return 2
 fi
 
 local url="$1"
 if (printf '%s' "$url" | head -n 1 | tr A-Z a-z | grep -q -e '^ytdl:'); then
  resolve_ytdl_uri "$url" >/dev/null
  local resolve_r=$?
  if [ $resolve_r -ne 0 ]; then
   echo "error: could not resolve ytdl: URI" >&2
   return $resolve_r
  fi
 fi
 
 local port="$PORT"
 if [  x"$2" != x"" ]; then
  port=$2
 fi
 
 export ___MAGIC___="$MAGIC"
 export ___URL___="$url"
 #echo "$url" >&2
 echo "Serving <$url> on <http://$HOST:$port>..." >&2
 ncat -l -k -e "$(abspath "$0")" "$HOST" "$port"
}


child_main() {
 local input_url="$___URL___"
 local url="$input_url"
 local name="$NAME"
 if (printf '%s' "$input_url" | head -n 1 | tr A-Z a-z | grep -q -e '^ytdl:'); then
  url="$(resolve_ytdl_uri "$input_url")"
  local resolve_r=$?
  if [ $resolve_r -ne 0 ]; then
   echo "error: could not resolve ytdl: URI" >&2
   return $resolve_r
  fi
 fi
 
 local re=
 if (printf '%s' "$url" | head -n 1 | grep -q -v -e '^[a-zA-Z+-]\+:') ||
    (printf '%s' "$url" | head -n 1 | grep -q -e '^file:'); then
  re='-re'
 fi
 
 local request_line=
 read -r request_line
 if (printf '%s' "$request_line" | egrep -q -v -i -e '^(GET|HEAD) .* HTTP/[^ ]+$'); then
  printf '%s\r\n' "HTTP/1.0 400 Bad Request" "" "<h1>400 Bad Request</h1>"
  return 1
 fi
 local method="$(printf '%s' "${request_line%% *}" | tr a-z A-Z)"
 local path="$(printf '%s' "$request_line" | sed -e 's@^[^ ]\+ @@; s@ HTTP/[^ ]\+$@@i')"
 
 local disposition=inline
 if (printf '%s' "$path" | egrep -q -i -e '[/?](dl|download)([?&].*)?$'); then
  disposition=attachment; re=''
  path="$(printf '%s' "$path" | sed -e 's@[/?]\(dl\|download\)\([?&].*\)\?$@@i')"
 fi
 path=${path%%\?*}
 
 if (printf '%s' "$path" | egrep -q -e '^/+[^/]'); then
  name="$(basename -- "$(printf '%s' "$path" | sed -e 's@^/*@@; s@/*$@@')")"
 fi
 
 if (printf '%s' "$name" | grep -q -v -e '\.[^.]\+$'); then
  name="$name.ogg"
 fi
 
 printf '%s\r\n' "HTTP/1.0 200 OK"
 printf '%s\r\n' "Content-Type: audio/ogg"
 printf '%s\r\n' "Content-Disposition: $disposition; filename=$name"
 printf '%s\r\n' "Cache-Control: no-transform"
 printf '%s\r\n' "Connection: close"
 printf '%s\r\n' "Server: $NAME"
 printf '\r\n'
 if [ x"$method" = x"HEAD" ]; then
  return 0
 fi
 
 exec ffmpeg -hide_banner -nostdin -loglevel fatal -y \
  $re -i "$url" \
  -vn \
  -c:a libopus -ac 1 -ar $AR -b:a ${AB}k -vbr off -application voip -packet_loss 10 \
  -f ogg -copyts \
  -map_metadata -1 -metadata title="${name%.*}" \
  -
}


resolve_ytdl_uri() {
 local DEFAULT_FORMAT="worstaudio;worst"
 
 local ytdl_uri="$1"
 local after_scheme="$(printf '%s' "$ytdl_uri" | sed -e 's@ytdl:/*@@')"
 local format="${after_scheme%%/*}"
 local url="${after_scheme#*/}"
 if (printf '%s' "$after_scheme" | grep -q -v -e '/'); then
  format="$DEFAULT_FORMAT"
  url="$after_scheme"
 elif (printf '%s' "$format" | head -n 1 | egrep -q -e '\.[^:]*:?$|:$') &&
      (printf '%s' "$format" | head -n 1 | grep -q -e '^[a-zA-Z.:_-]\+$'); then
  url="$format/$url" #url="$(printf '%s' "$format/$url" | sed -e "s@:/\+@://@")"
  format="$DEFAULT_FORMAT"
 fi
 format="$(printf '%s' "$format" | tr ';' '/')"
 
 if (printf '%s' "$url" | grep -q -e '^\(https\?:/*\)\?\([^.]\+\?\.\)\?twitch\.tv/') && \
    (printf '%s' "$format" | grep -q -v -e 'best\|worst'); then
  local format_len="$(printf '%s' "$format" | wc -c)"
  local format_upper="$(printf '%s' "$format" | tr 'a-z' 'A-Z')"
  local format_lower="$(printf '%s' "$format" | tr 'A-Z' 'a-z')"
  format=$(echo x | awk '{
   print substr(upper, 1, 1) substr(lower, 2, len - 1)
  }' upper="$format_upper" lower="$format_lower" len="$format_len")
 fi
 
 #echo "$format $url" >&2
 check_not_empty youtube-dl -g -f "$format" "$url" --playlist-end=1 --max-downloads=1 2>/dev/null && return
}


check_not_empty() {
 local output
 output=$("$@")
 local r=$?
 if [ $r -eq 0 ]; then
  r=1
 fi
 if [ x"$output" != x"" ]; then
  r=0
 fi
 printf '%s' "$output"
 return $r
}


abspath() {
 printf '%s\n' \
  "$(cd "$(dirname -- "$1")"; printf '%s' "$(pwd)")/$(basename -- "$1")"
}


is_child=0
if [ x"$___MAGIC___" = x"$MAGIC" ]; then
 is_child=1
 shift
fi

if [ $is_child -eq 0 ]; then
 main "$@"
else
 child_main "$@"
fi
