#!/usr/bin/env python2

"""Displays an image without a window border or background.
   
   Based on code from http://bit.ly/qfvule
   
"""

import argparse
import os
import sys

from collections import namedtuple

import cairo
import gtk
import pygtk

pygtk.require("2.0")


Padding = namedtuple("Padding", "top,right,bottom,left")


def _close_callback(window, data):
 """Called when the window is closed."""
 window.hide()
 gtk.main_quit()


def _drag_callback(window, e):
 """Called when the window is clicked on."""
 window.begin_move_drag(e.button,
                        int(round(e.x + window.window.get_root_origin()[0])),
                        int(round(e.y + window.window.get_root_origin()[1])),
                        e.time)

def make_transparent(window, event):
 """Makes a window transparent."""
 cr = window.window.cairo_create()
 # Sets the operator to clear which deletes everything below where an object is
 # drawn
 cr.set_operator(cairo.OPERATOR_CLEAR)
 # Makes the mask fill the entire window
 cr.rectangle(0.0, 0.0, *window.get_size())
 # Deletes everything in the window (since the compositing operator is clear
 # and mask fills the entire window
 cr.fill()
 # Set the compositing operator back to the default
 cr.set_operator(cairo.OPERATOR_OVER)

def display_transparent(image_filename, size_factor=1, opacity=1,
                        x=None, y=None, padding=None):
 if isinstance(padding, basestring):
  padding = [int(i.strip()) for i in padding.split(",")]
 if not padding:
  padding = [0, 0, 0, 0]
 elif len(padding) == 1:
  padding = padding * 4
 elif len(padding) == 2:
  padding = padding * 2
 elif len(padding) == 3:
  padding = [padding[0], padding[1], padding[2], padding[1]]
 elif len(padding) > 4:
  padding = padding[:4]
 pad = padding = Padding(*[int(round(i)) for i in padding])
 
 win = gtk.Window()
 win.set_title(os.path.basename(image_filename))
 win.set_decorated(False)
 win.set_resizable(False)
 win.set_opacity(opacity)
 
 # Make sure that the main loop terminates when the window is closed
 win.connect("delete-event", _close_callback)
 
 # Makes the window paintable, so we can draw directly on it
 win.set_app_paintable(True)
 
 # This sets the windows colormap, so it supports transparency.
 # This will only work if the wm support alpha channel
 screen = win.get_screen()
 rgba = screen.get_rgba_colormap()
 win.set_colormap(rgba)
 
 # This will actually make the window transparent.
 win.connect("expose-event", make_transparent)
 
 # Load and scale the image
 pixbuf = gtk.gdk.pixbuf_new_from_file(image_filename)
 width = int(round(pixbuf.get_width() * size_factor))
 height = int(round(pixbuf.get_height() * size_factor))
 if size_factor != 1:
  pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(image_filename,
            width, height)
 
 # Add the image to a Fixed container for padding purposes
 fixed = gtk.Fixed()
 img = gtk.image_new_from_pixbuf(pixbuf)
 fixed.add(img)
 fixed.move(img, pad.left, pad.top)
 
 # Add the container to the window
 width_padded = pixbuf.get_width() + pad.left + pad.right
 height_padded = pixbuf.get_height() + pad.top + pad.bottom
 win.set_size_request(width_padded, height_padded)
 win.add(fixed)
 
 # Make the window draggable
 win.connect("button-press-event", _drag_callback)
 win.add_events(gtk.gdk.BUTTON_PRESS_MASK)
 
 # Position window
 if x or y:
  x = str(x or "")
  if x and x[0] != "-":
   x = "+" + x
  y = str(y or "")
  if y and y[0] != "-":
   y = "+" + y
  win.parse_geometry(x+y)
 
 # Enter GTK main loop
 win.show_all()
 gtk.main()

def main(argv):
 parser = argparse.ArgumentParser(prog=argv[0],
           description="Displays an image with no background or"
                       " window decorations.")
 parser.add_argument("filename", help="The image to display")
 parser.add_argument("-s", "--size", type=float, default=100.,
                     help="Desired size of the image as a percentage")
 parser.add_argument("-o", "--opacity", type=float, default=100.,
                     help="Desired opacity of the image as a percentage")
 parser.add_argument("-x", type=str, default=None,
                     help="Initial X position (default: auto)")
 parser.add_argument("-y", type=str, default=None,
                     help="Initial X position (default: auto)")
 parser.add_argument("-p", "--padding", default=None,
                     help="Padding (default: None; format:"
                          " {all-sides} | {top/bottom},{left/right} |"
                          " {t},{r/l},{b} | {t},{r},{b},{l})")
 try:
  args = parser.parse_args(argv[1:])
 except SystemExit as exit:
  return exit.code
 
 display_transparent(args.filename, size_factor=args.size * 0.01,
                     opacity=args.opacity * 0.01, x=args.x, y=args.y,
                     padding=args.padding)

if __name__ == "__main__":
 try:
  sys.exit(main(sys.argv))
 except (KeyboardInterrupt, EOFError):
  pass
